import chain from "stream-chain";
import parser from "stream-json";
import { pick } from "stream-json/filters/Pick.js";
import { ignore } from "stream-json/filters/Ignore.js";
import { streamValues } from "stream-json/streamers/StreamValues.js";
import { streamArray } from "stream-json/streamers/StreamArray.js";
import { Transform } from "stream";

import zlib from "zlib";
// Here we hide the shady stuff we have to do to export the npm modules


export { chain, ignore, parser, pick, streamArray, streamValues };

// export function plainStreamArrayExtractor<T, K extends keyof T>(stream: Readable, key: K) {
//     const pipeline = stream // here we have a stream of bytes
//         .pipe(parser()) // stream the bytes of the first file into a parser
//         .pipe(pick({ filter: key })) // takes the entry called "matches"
//         .pipe(streamArray()); // takes the entries of "matches" and stream each token
//     return pipeline as Readable;
// }

export function tarGzStreamArrayExtractor<T, K extends string>(
  stream: ReadableStream,
  key: K,
) {
  const nodeStream = new Transform()

  stream.pipeTo(new WritableStream({
    write(value) {
      nodeStream.push(value)
    },
    close() {
      nodeStream.push(null)
    }
  }))
  const pipeline = nodeStream // here we have a stream of bytes
    .pipe(zlib.createGunzip()) // take the tar.gz archive and stream the content of the archive
    .pipe(parser()) // stream the bytes of the first file into a parser
    .pipe(pick({ filter: key })) // takes the entry called "matches"
    .pipe(streamArray()); // takes the entries of "matches" and stream each token
  return pipeline;
}

// export function blobTarGzStreamArrayExtractor<T, K extends keyof T = keyof T>(
//   blob: Blob,
//   key: K,
// ) {
//   const pipeline = Readable.from(blob.stream()) // here we have a stream of bytes
//     .pipe(zlib.createGunzip()) // take the tar.gz archive and stream the content of the archive
//     .pipe(parser()) // stream the bytes of the first file into a parser
//     .pipe(pick({ filter: key })) // takes the entry called "matches"
//     .pipe(streamArray()); // takes the entries of "matches" and stream each token
//   return pipeline as Readable;
// }
