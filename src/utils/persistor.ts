// deno-lint-ignore-file require-await
import { BulkWriteResult, Collection, MongoClient } from "npm:mongodb@5.0.1";

export interface Persistor<
  T,
  Identifier, // should add constraint on > Identifier part of T
> {
  /**
   * Find the first item corresponding to the criteria
   * <p>
   * Can only be found by the identifier
   * @param i
   */
  findOne(i: Identifier): Promise<T | undefined>;
  persistOne(items: T): Promise<number>;
  persistMany(items: T[]): Promise<number>;
  open(): Promise<void>;
  close(): Promise<void>;
}

// deno-lint-ignore ban-types
type Obj = {};

export interface PersistorFactory {
  make<Schema extends Obj, Identifier extends Obj>(
    databaseName: string,
    collectionName: string,
    getIdentifier: (t: Schema) => Identifier,
  ): Promise<Persistor<Schema, Identifier>>;
}

export class DebugPersistorFactory implements PersistorFactory {
  async make<Schema extends Obj, Identifier extends Obj>(
    databaseName: string,
    collectionName: string,
    getIdentifier: (t: Schema) => Identifier,
  ): Promise<Persistor<Schema, Identifier>> {
    return new DebugPersistor(databaseName, collectionName, getIdentifier);
  }
}

export class MongoPersistorFactory implements PersistorFactory {
  client: MongoClient;
  constructor(client: MongoClient) {
    this.client = client;
  }

  async make<Schema extends Obj, Identifier extends Obj>(
    databaseName: string,
    collectionName: string,
    getIdentifier: (t: Schema) => Identifier,
  ): Promise<Persistor<Schema, Identifier>> {
    const persistor = new MongoPersistor(
      databaseName,
      collectionName,
      getIdentifier,
      this.client,
    );

    return persistor;
  }
}

function countBulkOperations(result: BulkWriteResult) {
  const { insertedCount, modifiedCount, deletedCount, upsertedCount } = result;
  return (
    insertedCount + modifiedCount + deletedCount + upsertedCount
  );
}

/**
 * This only prints to log the data that should have been persisted
 */
export class DebugPersistor<T, I> implements Persistor<T, I> {
  databaseName: string;
  collectionName: string;
  getIdentifier: (t: T) => I;
  constructor(databaseName: string,
    collectionName: string,
    getIdentifier: (t: T) => I) {
    this.databaseName = databaseName;
    this.collectionName = collectionName;
    this.getIdentifier = getIdentifier;
  }

  async persistMany(items: T[]): Promise<number> {
    console.log(items);
    return items.length;
  }

  async findOne(_i: I): Promise<T | undefined> {
    return undefined;
  }

  persistOne(items: T): Promise<number> {
    return this.persistMany([items]);
  }
  async close(): Promise<void> {
    return undefined;
  }

  async open(): Promise<void> {
    return undefined;
  }
}

/**
 * Persists the data to a mongo collection using a configured mongo client
 */
export class MongoPersistor<
  DatabaseName extends string,
  CollectionName extends string,
  Schema extends Obj,
  Identifier extends Obj,
> implements Persistor<Schema, Identifier> {
  databaseName: DatabaseName;
  collectionName: CollectionName;
  getIdentifier: (t: Schema) => Identifier;
  client: MongoClient;
  collection: Collection;

  constructor(
    databaseName: DatabaseName,
    collection: CollectionName,
    getIdentifier: (t: Schema) => Identifier,
    client: MongoClient,
  ) {
    this.databaseName = databaseName;
    this.collectionName = collection;
    this.getIdentifier = getIdentifier;
    this.client = client;
    this.collection = this.client.db(this.databaseName).collection(
      this.collectionName,
    );
  }

  async persistMany(items: Schema[]): Promise<number> {
    const bulk = items.map((item) => ({
      replaceOne: {
        filter: this.getIdentifier(item),
        replacement: item,
        upsert: true,
      },
    }));
    const batchInsertResult = await this.collection.bulkWrite(
      bulk,
    );
    return countBulkOperations(batchInsertResult);
  }
  async open(): Promise<void> {
    await this.client.connect();
  }

  persistOne(items: Schema): Promise<number> {
    return this.persistMany([items]);
  }

  async close(): Promise<void> {
    await this.client.close();
  }
  findOne(i: Identifier): Promise<Schema | undefined> {
    return this.collection.findOne(i) as unknown as Promise<Schema | undefined>;
  }
}
