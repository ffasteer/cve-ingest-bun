import { PoolExecutor } from "./pool.ts";

export interface Batcher<T> {
  enqueue(item: T): Promise<void>;
  flush(): Promise<void>;
}

export class SimpleBatcher<T> implements Batcher<T> {
  readonly size: number;
  protected items: T[];
  protected readonly batches: T[][] = [];
  protected readonly flusher: (items: T[]) => Promise<unknown>;
  protected readonly pool: PoolExecutor;

  constructor(
    size: number,
    flusher: (items: T[]) => Promise<unknown>,
    pool: PoolExecutor,
  ) {
    this.size = size;
    this.items = [];
    this.flusher = flusher;
    this.pool = pool;
  }

  // deno-lint-ignore require-await
  enqueue = async (item: T) => {
    this.items.push(item);
    if (this.items.length === this.size) {
      return this.flush(); // note: awaiting is not required here
    }
  };

  async flush() {
    this.batches.push([...this.items]);
    this.items = [];
    this.pool.submit(() => this.flusher(this.batches.pop() || []));
    return await this.pool.isEmpty();
  }
}

export class MultiBatcher<T> implements Batcher<T> {
  readonly size: number;
  readonly plexNumber: number;
  protected items: T[];
  protected batched: T[] = [];
  protected flusher: (items: T[]) => Promise<unknown>;
  constructor(
    size: number,
    plexNumber: number,
    flusher: (items: T[]) => Promise<unknown>,
  ) {
    this.size = size;
    this.plexNumber = plexNumber;
    this.items = [];
    this.flusher = flusher;
  }

  async enqueue(item: T) {
    this.items.push(item);
    if (this.items.length === this.size) {
      return await this.flush(); // note: awaiting is not required here
    }
  }

  async flush() {
    const all: Promise<unknown>[] = [];
    const chunkSize = this.size / this.plexNumber;
    for (let i = 0; i < this.items.length; i += chunkSize) {
      const chunk = this.items.slice(i, i + chunkSize);
      all.push(this.flusher(chunk));
    }
    await Promise.all(all);
    this.items = [];
  }
}
