import { Milliseconds } from "./types.ts";

export function toMs(n: number) {
  return n as Milliseconds;
}

export function sleep(s: Milliseconds) {
  return new Promise<void>((resolve) => {
    setTimeout(() => resolve(), s);
  });
}

export class Counter {
  value = 0;
  increment() {
    this.value++;
  }
  decrement() {
    this.value--;
  }
  get() {
    return this.value;
  }
}

export class PoolExecutor {
  concurrency: number;
  protected pending = new Counter();
  protected waiting = new Counter();

  constructor(concurrency: number) {
    this.concurrency = concurrency;
  }

  getWaiting() {
    return this.waiting.get();
  }

  submit = (f: () => Promise<unknown>) => {
    return new Promise<void>(async (resolve) => {
      this.waiting.increment();
      // await this.isReady()
      while (this.pending.get() > this.concurrency) {
        // console.log('pending is', this.pending, this.concurrency);
        await sleep(toMs(100));
      }
      console.log('1am ready, calling');
      // console.log('am ready');
      this.waiting.decrement();
      this.pending.increment();
      f().finally(() => {
        this.pending.decrement();
        resolve();
      });
    });
  }

  // protected isReady = async () => {
  //   // console.log('called ready');
  //   while (this.pending.get() > this.concurrency) {
  //     // console.log('pending is', this.pending, this.concurrency);
  //     await sleep(toMs(100));
  //   }
  //   console.log('am ready');
  //   return true;
  // }

  isPending = () => {
    return this.pending.get() > 1;
  };

  async isEmpty() {
    while (this.pending.get() > 0 || this.waiting.get() > 0) {
      await sleep(toMs(5000)); // ms
    }
  }
}
